#

<div id="md-top">
  <h1>1. Дискретная математика, математическая логика и теория алгоритмов</h1>
</div>

<hr/>
<ol>
  <li>⚠️ <a href="#_1"> Множества, их спецификации; диаграммы Венна; отношения; свойства отношений; разбиения и отношение эквивалентности; отношение порядка; функции и отображения; операции. </a></li>
  <li>❌ <a href="#_2"> Основные понятия теории графов; маршруты; циклы; связность; планарные графы </a></li>
  <li>❌ <a href="#_3"> Переключательные функции (ПФ); способы задания ПФ; специальные разложения ПФ; неполностью определенные (частные) ПФ; минимизация ПФ и неполностью определенных ПФ </a></li>
  <li>❌ <a href="#_4"> Теорема о функциональной полноте; примеры функционально-полных базисов </a></li>
  <li>❌ <a href="#_5"> Разрешимые и неразрешимые проблемы; схемы алгоритмов; схемы потоков данных </a></li>
  <li>❌ <a href="#_6"> Логика высказываний; логика предикатов; исчисления; непротиворечивость; полнота; синтаксис и семантика языка логики предикатов. Клаузальная форма. Метод резолюций в логике предикатов. Принцип логического программирования </a></li>
  <li>❌ <a href="#_7"> Темпоральные логики; нечеткая и модальные логики; нечеткая арифметика; алгоритмическая логика Ч. Хоара. Логика высказываний. Логическое следование, принцип дедукции. Метод резолюций </a></li>
  <li>❌ <a href="#_8"> Аксиоматические системы, формальный вывод. Метатеория формальных систем. Понятие алгоритмической системы. Рекурсивные функции </a></li>
  <li>❌ <a href="#_9"> Формализация понятия алгоритма; Машина Тьюринга. Тезис Черча; Алгоритмически неразрешимые проблемы. Меры сложности алгоритмов. Легко и трудноразрешимые задачи </a></li>
  <li>⚠️ <a href="#_10"> Классы задач Р и NP. NP - полные задачи. Понятие сложности вычислений; эффективные алгоритмы. Основы нечеткой логики. Элементы алгоритмической логики. Погрешности вычислений; устойчивость и сложность алгоритма (по памяти, по времени). Математические программные системы </a></li>
</ol>
<hr/>
<br />

## 1

<h2> 1. Множества, их спецификации; диаграммы Венна; отношения; свойства отношений; разбиения и отношение эквивалентности; отношение порядка; функции и отображения; операции. </h2>

<b>Множества</b>

1. Множества:

   - Операции над множествами:
     - Объединение (A ∪ B) - возвращает множество, содержащее все элементы, которые принадлежат хотя бы одному из множеств A или B.
     - Пересечение (A ∩ B) - возвращает множество, содержащее только элементы, которые принадлежат как множеству A, так и множеству B.
     - Разность (A \ B) - возвращает множество, содержащее все элементы, которые принадлежат множеству A, но не принадлежат множеству B.
     - Дополнение (A') - возвращает множество, содержащее все элементы, которые не принадлежат множеству A (относительно некоторого универсального множества).

<details>
<summary>Примеры:</summary>

Предположим, у нас есть два множества:

A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

1. Объединение (A ∪ B):
   Результатом объединения множеств A и B будет множество, содержащее все элементы, которые принадлежат хотя бы одному из множеств A или B.
   A ∪ B = {1, 2, 3, 4, 5, 6}

2. Пересечение (A ∩ B):
   Результатом пересечения множеств A и B будет множество, содержащее только элементы, которые принадлежат и множеству A, и множеству B.
   A ∩ B = {3, 4}

3. Разность (A \ B):
   Результатом разности множеств A и B будет множество, содержащее все элементы, которые принадлежат множеству A, но не принадлежат множеству B.
   A \ B = {1, 2}

4. Дополнение (A'):
   Предположим, что у нас есть некоторое универсальное множество U, которое содержит все возможные элементы. Дополнение множества A относительно U будет содержать все элементы, которые не принадлежат множеству A.
   Пусть U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.
   Тогда A' = U \ A = {5, 6, 7, 8, 9, 10}.

</details>

<hr />

<b>Отношения</b>

2.  Отношения:

    - Свойства отношений:
      - Рефлексивность - отношение R на множестве A является рефлексивным, если каждый элемент множества A связан с самим собой.
      - Симметричность - отношение R на множестве A является симметричным, если для любых двух элементов a и b из множества A, если a связано с b, то b также связано с a.
      - Транзитивность - отношение R на множестве A является транзитивным, если для любых трех элементов a, b и c из множества A, если a связано с b и b связано с c, то a также связано с c.

<details>
<summary>Примеры:</summary>

Предположим, у нас есть отношение R на множестве A, где A = {1, 2, 3, 4}.

1.  Рефлексивность:
    Отношение R будет рефлексивным, если каждый элемент множества A связан с самим собой.
    Пример: R = {(1, 1), (2, 2), (3, 3), (4, 4)} - каждый элемент из A связан с самим собой, поэтому отношение R является рефлексивным.

2.  Симметричность:
    Отношение R будет симметричным, если для любых двух элементов a и b из множества A, если a связано с b, то b также связано с a.
    Пример: R = {(1, 2), (2, 1), (3, 4), (4, 3)} - если (a, b) принадлежит R, то (b, a) также принадлежит R. Отношение R является симметричным.

3.  Транзитивность:
    Отношение R будет транзитивным, если для любых трех элементов a, b и c из множества A, если a связано с b и b связано с c, то a также связано с c.
    Пример: R = {(1, 2), (2, 3), (1, 3)} - если (a, b) и (b, c) принадлежат R, то (a, c) также принадлежит R. Отношение R является транзитивным.

</details>

<hr />

<b>Разбиения и отношение эквивалентности</b>

3. Разбиения и отношение эквивалентности:

   - Разбиение множества:
     - Разбиение множества A представляет собой набор непересекающихся подмножеств A1, A2, ..., An, таких что объединение этих подмножеств равно множеству A (A = A1 ∪ A2 ∪ ... ∪ An) и любые два подмножества Ai и Aj не имеют общих элементов (Ai ∩ Aj = ∅).
   - Отношение эквивалентности:
     - Отношение эквивалентности на множестве A обладает свойствами рефлексивности, симметричности и транзитивности. Оно разбивает множество A на классы эквивалентности, где элементы в каждом классе эквивалентности связаны друг с другом.

<details>
<summary>Примеры:</summary>

1. Разбиение множества:
   Разбиение множества A - это набор непересекающихся подмножеств A, объединение которых равно множеству A.
   Пример: Пусть A = {1, 2, 3, 4}. Тогда одно из возможных разбиений множества A будет:
   {{1, 4}, {2}, {3}}
   Здесь мы разделили множество A на три непересекающихся подмножества, и их объединение равно множеству A.

2. Отношение эквивалентности:
   Отношение эквивалентности на множестве A - это отношение, которое обладает тремя свойствами: рефлексивностью, симметричностью и транзитивностью.
   Пример: Пусть A = {1, 2, 3, 4}, и у нас есть отношение R на A, заданное следующим образом:
   R = {(1, 1), (2, 2), (3, 3), (4, 4), (1, 4), (4, 1)}
   Здесь отношение R является отношением эквивалентности, так как оно удовлетворяет всем трем свойствам:
   - Рефлексивность: Каждый элемент из A связан с самим собой.
   - Симметричность: Если (a, b) принадлежит R, то (b, a) также принадлежит R.
   - Транзитивность: Если (a, b) и (b, c) принадлежат R, то (a, c) также принадлежит R.

Отношение эквивалентности определяет классы эквивалентности, которые разбивают множество на непересекающиеся подмножества. В примере выше классы эквивалентности будут:
[1, 4] - содержит элементы, которые связаны между собой отношением R.
[2] - содержит элемент 2, так как он связан только с самим собой.
[3] - содержит элемент 3, так как он связан только с самим собой.

</details>

<hr />

<b>Отношение порядка</b>

4. Отношение порядка:

   - Отношение порядка на множестве A:
     - Рефлексивность - каждый элемент множества A связан с самим собой.
     - Антисимметричность - если элемент a связан с элементом b и элемент b связан с элементом a, то a и b являются одним и тем же элементом.
     - Транзитивность - если элемент a связан с элементом b и элемент b связан с элементом c, то элемент a также связан с элементом c.

<details>
<summary>Примеры:</summary>

1. Частичный порядок:
   Частичный порядок на множестве A - это отношение, которое обладает свойствами рефлексивности, антисимметричности и транзитивности.
   Пример: Пусть A = {1, 2, 3, 4}, и у нас есть отношение R на A, заданное следующим образом:
   R = {(1, 1), (2, 2), (3, 3), (4, 4), (1, 2), (2, 3)}
   Здесь отношение R является частичным порядком, так как оно удовлетворяет всем трем свойствам:

   - Рефлексивность: Каждый элемент из A связан с самим собой.
   - Антисимметричность: Если (a, b) и (b, a) принадлежат R, то a = b.
   - Транзитивность: Если (a, b) и (b, c) принадлежат R, то (a, c) также принадлежит R.

2. Линейный порядок:
   Линейный порядок на множестве A - это частичный порядок, в котором для любых двух элементов a и b из A либо (a, b) принадлежит R, либо (b, a) принадлежит R.
   Пример: Пусть A = {1, 2, 3, 4}, и у нас есть отношение R на A, заданное следующим образом:
   R = {(1, 1), (2, 2), (3, 3), (4, 4), (1, 2), (2, 3), (1, 3)}
   Здесь отношение R является линейным порядком, так как для любых двух элементов из A либо один элемент связан с другим, либо другой элемент связан с первым.

Отношение порядка используется для упорядочивания элементов множества

</details>

<hr />

<b>Функции и отображения</b>

5. Функции и отображения:

   - Инъективность - функция f является инъективной (или однозначным отображением), если каждому элементу из множества A соответствует не более одного элемента из множества B. То есть, разные элементы из множества A должны иметь разные образы в множестве B.
   - Сюръективность - функция f является сюръективной (или на), если каждый элемент из множества B имеет хотя бы один прообраз в множестве A. То есть, образы функции f покрывают всё множество B.
   - Биективность - функция f является биективной, если она одновременно инъективна и сюръективна. То есть, каждому элементу из множества A соответствует ровно один элемент из множества B, и образы функции f покрывают всё множество B.

<details>
<summary>Примеры:</summary>

1. Функция:
   Функция f: A → B является правилом, которое каждому элементу из множества A сопоставляет единственный элемент из множества B.
   Пример: Пусть A = {1, 2, 3} и B = {a, b, c}. Тогда функция f, заданная следующим образом, является примером функции:
   f(1) = a
   f(2) = b
   f(3) = c
   Здесь каждому элементу из множества A сопоставляется единственный элемент из множества B.

2. Инъективная функция:
   Инъективная функция, также известная как инъекция или однозначное отображение, является функцией, которая каждому элементу из множества A сопоставляет разные элементы из множества B.
   Пример: Пусть A = {1, 2, 3} и B = {a, b, c, d}. Тогда функция f, заданная следующим образом, является примером инъективной функции:
   f(1) = a
   f(2) = b
   f(3) = c
   Здесь каждому элементу из множества A сопоставляются разные элементы из множества B.

3. Сюръективная функция:
   Сюръективная функция, также известная как сюръекция или наложение, является функцией, которая обеспечивает, чтобы каждый элемент из множества B был сопоставлен хотя бы одному элементу из множества A.
   Пример: Пусть A = {1, 2, 3} и B = {a, b, c, d}. Тогда функция f, заданная следующим образом, является примером сюръективной функции:
   f(1) = a
   f(2) = b
   f(3) = c
   f(4) = d
   Здесь каждый элемент из множества B имеет хотя бы один элемент из множества A, который ему сопоставлен.

</details>

<hr />

<b>Операции</b>

6. Операции:
   - В дополнение к операциям над множествами, которые были упомянуты ранее, есть также:
     - Декартово произведение (A × B) - возвращает множество всех упорядоченных пар (a, b), где a принадлежит множеству A, а b принадлежит множеству B.
     - Сумма множеств (A + B) - возвращает множество, содержащее все элементы, которые принадлежат множеству A или множеству B (без повторений).

<details>
<summary>Примеры:</summary>

1. Арифметические операции:
   Арифметические операции выполняются над числами и включают сложение, вычитание, умножение и деление.
   Пример: Пусть у нас есть два числа a = 5 и b = 3. Тогда примеры арифметических операций над этими числами:

   - Сложение: a + b = 5 + 3 = 8
   - Вычитание: a - b = 5 - 3 = 2
   - Умножение: a _ b = 5 _ 3 = 15
   - Деление: a / b = 5 / 3 ≈ 1.667

2. Логические операции:
   Логические операции выполняются над логическими значениями (истина или ложь) и включают операции "и" (AND), "или" (OR) и "не" (NOT).
   Пример: Пусть у нас есть два логических значения p = true и q = false. Тогда примеры логических операций над этими значениями:

   - "И" (AND): p && q = true && false = false
   - "ИЛИ" (OR): p || q = true || false = true
   - "НЕ" (NOT): !p = !true = false

3. Множественные операции:
   Множественные операции выполняются над множествами и включают операции объединения, пересечения и разности.
   Пример: Пусть у нас есть два множества A = {1, 2, 3} и B = {3, 4, 5}. Тогда примеры множественных операций над этими множествами:
   - Объединение: A ∪ B = {1, 2, 3} ∪ {3, 4, 5} = {1, 2, 3, 4, 5}
   - Пересечение: A ∩ B = {1, 2, 3} ∩ {3, 4, 5} = {3}
   - Разность: A \ B = {1, 2, 3} \ {3, 4, 5} = {1, 2}

</details>

<hr />

<p align="right"><a href="#md-top">К содержанию</a></p>
<hr/>

## 10

<h2> 10. Классы задач Р и NP. NP - полные задачи. Понятие сложности вычислений; эффективные алгоритмы. Основы нечеткой логики. Элементы алгоритмической логики. Погрешности вычислений; устойчивость и сложность алгоритма (по памяти, по времени). Математические программные системы </h2>

<b>Классы задач Р и NP</b>

1. Классы задач Р и NP:

   - Класс P (Polynomial Time) включает в себя задачи, которые могут быть решены за полиномиальное время от размера входных данных. То есть существует эффективный алгоритм, который может решить задачу за разумное время.
   - Класс NP (Nondeterministic Polynomial Time) включает в себя задачи, для которых существует неоднозначный алгоритм, позволяющий проверить правильность решения за полиномиальное время. Однако, само решение задачи может потребовать экспоненциальное время.
   - NP-полные задачи являются самыми сложными задачами в классе NP. Если существует полиномиальный алгоритм для решения хотя бы одной NP-полной задачи, то существует полиномиальный алгоритм для решения всех NP-полных задач.

<details>
<summary>Примеры:</summary>

P (Polynomial Time):

- Сортировка массива: Задача состоит в упорядочивании элементов массива по возрастанию или убыванию. Существуют эффективные алгоритмы с полиномиальной сложностью, такие как сортировка слиянием (Merge Sort) или быстрая сортировка (Quick Sort).
- Поиск наименьшего пути в графе: Задача состоит в нахождении кратчайшего пути между двумя вершинами в графе. Алгоритм Дейкстры и алгоритм Флойда-Уоршелла являются эффективными алгоритмами с полиномиальной сложностью для решения этой задачи.

NP (Nondeterministic Polynomial Time):

- Задача о коммивояжере (Traveling Salesman Problem): Задача состоит в нахождении кратчайшего замкнутого маршрута, который проходит через все города, посещая каждый город только один раз, и возвращается в исходный город. Проверка правильности решения может быть выполнена за полиномиальное время, но само решение задачи требует экспоненциального времени.
- Задача о рюкзаке (Knapsack Problem): Задача состоит в выборе оптимального набора предметов для упаковки в рюкзак с ограниченной вместимостью, чтобы максимизировать общую стоимость предметов. Проверка правильности решения может быть выполнена за полиномиальное время, но само решение задачи требует экспоненциального времени.

NP-полных:

- Задача о выполнимости булевой формулы (Boolean Satisfiability Problem): Задача состоит в определении, существует ли набор значений переменных, при котором булева формула становится истинной. Эта задача является одной из самых известных NP-полных задач.
- Задача о разбиении множества (Subset Sum Problem): Задача состоит в определении, существует ли подмножество заданного множества, сумма элементов которого равна заданному числу. Эта задача также является NP-полной.

</details>

<hr/>

2. Понятие сложности вычислений и эффективные алгоритмы:

   - Сложность вычислений отражает количество ресурсов (время, память) необходимых для решения задачи.
   - Эффективные алгоритмы - это алгоритмы, которые решают задачу за разумное время и используют ограниченное количество ресурсов. Они обычно имеют полиномиальную сложность.

<details>
<summary>Примеры:</summary>

1. Сложность вычислений:

   - Возведение числа в степень: Для данной задачи сложность вычислений зависит от значения показателя степени. Если показатель степени является константой, то сложность вычислений будет линейной, то есть O(n), где n - размер числа. Однако, если показатель степени также является входными данными, то сложность вычислений будет экспоненциальной, то есть O(2^n), где n - количество битов в показателе степени.
   - Умножение матриц: Сложность вычислений для умножения двух матриц размером n x n составляет O(n^3), где n - размерность матрицы. Это означает, что время выполнения алгоритма увеличивается в кубической зависимости от размера матрицы.

2. Эффективные алгоритмы:
   - Сортировка слиянием (Merge Sort): Это эффективный алгоритм сортировки, который работает за время O(n log n), где n - количество элементов в массиве. Алгоритм разделяет исходный массив на две половины, рекурсивно сортирует каждую половину, а затем объединяет их в отсортированный массив.
   - Поиск в сортированном массиве (Binary Search): Это эффективный алгоритм для поиска элемента в отсортированном массиве. Алгоритм работает за время O(log n), где n - количество элементов в массиве. Алгоритм сравнивает искомый элемент с элементом в середине массива и, исходя из результата сравнения, сужает область поиска в два раза на каждой итерации.
   - Алгоритм Дейкстры (Dijkstra's Algorithm): Это эффективный алгоритм для нахождения кратчайшего пути во взвешенном графе. Алгоритм работает за время O((V + E) log V), где V - количество вершин в графе, а E - количество ребер. Алгоритм постепенно строит кратчайшие пути от начальной вершины ко всем остальным вершинам, используя жадный подход.

</details>

<hr/>

3. Основы нечеткой логики:

   - Нечеткая логика - это логика, которая позволяет работать с нечеткими или неопределенными понятиями. В отличие от классической булевой логики, где значения могут быть только истинными или ложными, нечеткая логика позволяет использовать промежуточные значения (нечеткие множества) для описания неопределенности.
   - Нечеткая логика широко применяется в системах управления, принятии решений и моделировании нечетких понятий.

<details>
<summary>Примеры:</summary>

1. Управление климатической системой: Представим, что у нас есть климатическая система, которая должна поддерживать комфортную температуру в помещении. Вместо использования жестких правил, основанных на точных значениях температуры, можно применить нечеткую логику. Например, можно определить нечеткие множества "холодно", "тепло" и "горячо" с соответствующими функциями принадлежности. Затем можно определить правила управления, основанные на нечетких условиях, например: "Если температура холодная и наружная температура холодная, то включить отопление на среднюю мощность". Таким образом, нечеткая логика позволяет учесть неопределенность и размытость в определении комфортной температуры.

2. Оценка качества продукта: При оценке качества продукта могут существовать различные нечеткие понятия, такие как "хорошее", "среднее" и "плохое". Вместо использования жестких критериев, нечеткая логика позволяет учесть неопределенность и субъективность в оценке. Например, можно определить нечеткие множества "высокое качество", "среднее качество" и "низкое качество" с соответствующими функциями принадлежности. Затем можно определить правила оценки, основанные на нечетких условиях, например: "Если продукт имеет высокую производительность и низкую стоимость, то оценить его как высокое качество". Таким образом, нечеткая логика позволяет учесть размытость и неопределенность в оценке качества.

3. Автоматическое управление транспортным потоком: В городах с большим количеством автомобилей и перекрестков может быть сложно оптимизировать транспортный поток. Нечеткая логика может быть использована для принятия решений об управлении светофорами. Например, можно определить нечеткие множества "малая загруженность", "средняя загруженность" и "высокая загруженность" с соответствующими функциями принадлежности. Затем можно определить правила управления, основанные на нечетких условиях, например: "Если загруженность дороги высокая и загруженность перекрестка высокая, то увеличить время сигнала светофора". Таким образом, нечеткая логика позволяет учесть неопределенность и размытость в оптимизации транспортного потока.

</details>

4. Элементы алгоритмической логики:

   - Алгоритмическая логика изучает формальные методы и структуры для описания и анализа алгоритмов.
   - Она включает в себя понятия такие как последовательности, условия, циклы, подпрограммы и структуры данных, которые используются для построения эффективных алгоритмов.

<details>
<summary>Примеры:</summary>

1. Последовательность действий: Один из основных элементов алгоритмической логики - это последовательность действий, которые должны быть выполнены в определенном порядке. Например, если у нас есть алгоритм для приготовления кофе, то последовательность действий может быть следующей: включить кофеварку, поместить кофейные зерна в фильтр, добавить воду, нажать кнопку "включить". Последовательность действий определяет порядок выполнения операций.

2. Условные операторы: Условные операторы позволяют выполнять различные действия в зависимости от условий. Например, в алгоритме для приготовления кофе мы можем использовать условный оператор для проверки, есть ли вода в резервуаре кофеварки. Если вода отсутствует, то мы можем вывести сообщение "Добавьте воду" и остановить алгоритм. Условные операторы позволяют программе принимать решения на основе определенных условий.

3. Циклы: Циклы позволяют выполнять набор действий несколько раз. Например, в алгоритме для приготовления кофе мы можем использовать цикл для повторения процесса заваривания, пока не будет достигнута желаемая крепость кофе. Циклы позволяют автоматизировать повторяющиеся операции и упрощают написание алгоритмов.

4. Переменные: Переменные используются для хранения и обработки данных в алгоритмах. Например, в алгоритме для приготовления кофе мы можем использовать переменные для хранения количества кофейных зерен, объема воды, времени заваривания и других параметров. Переменные позволяют алгоритмам работать с данными и выполнять вычисления.

5. Ввод и вывод данных: Ввод и вывод данных являются важными элементами алгоритмической логики. Они позволяют пользователю взаимодействовать с алгоритмом и обмениваться информацией. Например, в алгоритме для приготовления кофе мы можем использовать операции ввода для получения количества кофейных зерен и объема воды от пользователя, а операции вывода для вывода сообщений и результатов.

</details>

5. Погрешности вычислений, устойчивость и сложность алгоритма:

   - Сложность алгоритма определяет количество ресурсов, необходимых для его выполнения. Существуют различные метрики сложности, такие как временная сложность (количество операций, необходимых для завершения алгоритма) и пространственная сложность (количество памяти, требуемой для выполнения алгоритма).
   - Хорошо разработанные алгоритмы стремятся минимизировать сложность и использование ресурсов, чтобы достичь наилучшей производительности.

<details>
<summary>Примеры:</summary>

1. Погрешности вычислений:

   - Погрешность округления: При вычислениях с числами с плавающей точкой может возникать погрешность округления, когда результат округляется до определенного числа знаков после запятой. Например, при делении числа 1 на 3 результатом будет 0.3333333333333333, где бесконечная десятичная дробь округлена до конечного числа знаков.
   - Погрешность приближения: При использовании приближенных методов, например, численных методов для решения уравнений или интегрирования, может возникать погрешность приближения, когда точность результата зависит от шага или других параметров метода. Чем больше шаг или меньше точность метода, тем больше погрешность приближения.

2. Устойчивость алгоритма:

   - Устойчивый алгоритм: Устойчивый алгоритм сохраняет свою точность и надежность при малых изменениях входных данных. Например, если алгоритм для решения системы линейных уравнений остается точным и надежным при небольших изменениях коэффициентов системы, то он считается устойчивым.
   - Неустойчивый алгоритм: Неустойчивый алгоритм может давать неверные или неточные результаты при малых изменениях входных данных. Например, если алгоритм для решения системы линейных уравнений дает сильно отличающиеся результаты при небольших изменениях коэффициентов системы, то он считается неустойчивым.

3. Сложность алгоритма:
   - Временная сложность: Временная сложность алгоритма описывает, как быстро алгоритм выполняется в зависимости от размера входных данных. Например, алгоритм с линейной временной сложностью (O(n)) будет выполняться пропорционально количеству элементов во входных данных.
   - Пространственная сложность: Пространственная сложность алгоритма описывает, сколько памяти требуется для выполнения алгоритма в зависимости от размера входных данных. Например, алгоритм с линейной пространственной сложностью (O(n)) будет требовать памяти пропорционально количеству элементов во входных данных.

Примеры погрешностей вычислений, устойчивости и сложности алгоритма демонстрируют, как ошибки и неопределенности могут возникать в процессе вычислений, как алгоритмы могут быть устойчивыми или неустойчивыми к изменениям входных данных, а также как сложность алгоритма может влиять на его производительность и требования к ресурсам.

</details>

6. Математические программные системы:
   - Математические программные системы (МПС) представляют собой программное обеспечение, разработанное для решения математических задач.
   - Они включают в себя различные математические функции, алгоритмы и инструменты для решения задач, связанных с численным анализом, оптимизацией, алгеброй, геометрией и другими областями математики.
   - Математические программные системы обычно предоставляют удобный интерфейс для ввода математических выражений, выполнения вычислений и визуализации результатов.

<details>
<summary>Примеры:</summary>
Примеры математических программных систем:

1. MATLAB: MATLAB (Matrix Laboratory) является одной из наиболее популярных математических программных систем. Она предоставляет мощные инструменты для численного анализа, моделирования и визуализации данных. MATLAB имеет широкий спектр функций и библиотек для работы с матрицами, символьными вычислениями, оптимизацией, статистикой и другими областями математики. Она также поддерживает разработку собственных скриптов и функций на языке программирования MATLAB.

2. Mathematica: Mathematica является мощной математической системой, разработанной компанией Wolfram Research. Она предоставляет широкий набор инструментов для символьных и численных вычислений, аналитической геометрии, статистики, оптимизации и других математических областей. Mathematica также имеет богатую библиотеку функций и возможности визуализации данных. Она поддерживает разработку программ на собственном языке программирования Wolfram Language.

3. R: R является языком программирования и средой разработки, специально созданными для статистического анализа и визуализации данных. Он предоставляет множество пакетов и библиотек для работы с различными статистическими методами, машинным обучением, временными рядами, графиками и другими математическими задачами. R также позволяет разработчикам создавать собственные функции и пакеты для расширения его функциональности.

4. Octave: Octave является свободным и открытым программным обеспечением, предоставляющим среду для численных вычислений и разработки математических алгоритмов. Он совместим с MATLAB и предлагает похожий набор функций для работы с матрицами, графиками, статистикой и другими математическими операциями. Octave поддерживает скриптовый язык программирования, который позволяет разработчикам создавать собственные алгоритмы и функции.

5. SageMath: SageMath (ранее известный как Sage) является математической программной системой, объединяющей различные математические пакеты и инструменты в единую среду. Он предоставляет возможности для символьных и численных вычислений, графики, алгебры, комбинаторики, геометрии и других математических областей. SageMath использует язык программирования Python и предоставляет широкий набор функций и библиотек для математического моделирования и исследований.

</details>

<hr/>
<p align="right"><a href="#md-top">К содержанию</a></p>
<hr/>
